/* tslint:disable */
/* eslint-disable */
/**
 * Billetera Virtual - Servidor Client
 * API REST que actúa como puente entre el cliente web y el servidor-database
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ClienteConfirmacionEntity {
    /**
     * Documento del cliente
     */
    'documento': string;
    /**
     * Nombre del cliente
     */
    'nombres': string;
}
export interface ClienteRecargaEntity {
    /**
     * Documento del cliente
     */
    'documento': string;
    /**
     * Nombre del cliente
     */
    'nombres': string;
}
export interface ClienteResponseEntity {
    /**
     * ID único del cliente
     */
    'id': number;
    /**
     * Documento de identidad del cliente
     */
    'documento': string;
    /**
     * Nombre completo del cliente
     */
    'nombres': string;
    /**
     * Email del cliente
     */
    'email': string;
    /**
     * Número de celular del cliente
     */
    'celular': string;
    /**
     * Saldo actual de la billetera
     */
    'saldo': string;
    /**
     * Fecha de creación
     */
    'createdAt': string;
    /**
     * Fecha de última actualización
     */
    'updatedAt': string;
}
export interface ClienteSaldoEntity {
    /**
     * Documento del cliente
     */
    'documento': string;
    /**
     * Nombre del cliente
     */
    'nombres': string;
    /**
     * Email del cliente (parcialmente oculto)
     */
    'email': string;
}
export interface ConfirmarPagoDto {
    /**
     * ID de la sesión de compra generado al iniciar el pago
     */
    'id_sesion': string;
    /**
     * Token de confirmación de 6 dígitos enviado al email
     */
    'token': string;
}
export interface ConfirmarPagoResponseEntity {
    /**
     * Datos del cliente
     */
    'cliente': ClienteConfirmacionEntity;
    /**
     * Monto descontado de la billetera
     */
    'montoDescontado': string;
    /**
     * Saldo anterior antes del pago
     */
    'saldoAnterior': string;
    /**
     * Saldo nuevo después del pago
     */
    'saldoNuevo': string;
    /**
     * Fecha y hora de la transacción
     */
    'fechaTransaccion': string;
}
export interface EstadisticasEntity {
    /**
     * Total de recargas realizadas
     */
    'totalRecargas': string;
    /**
     * Total de compras realizadas
     */
    'totalCompras': string;
    /**
     * Número de recargas
     */
    'numeroRecargas': number;
    /**
     * Número de compras
     */
    'numeroCompras': number;
}
export interface PagarDto {
    /**
     * Número de documento de identidad del cliente
     */
    'documento': string;
    /**
     * Número de teléfono celular del cliente
     */
    'celular': string;
    /**
     * Monto de la compra a realizar
     */
    'monto': number;
}
export interface PagoIniciadoResponseEntity {
    /**
     * ID de la sesión de pago generado
     */
    'id_sesion': string;
}
export interface RecargaBilleteraDto {
    /**
     * Número de documento de identidad del cliente
     */
    'documento': string;
    /**
     * Número de teléfono celular del cliente
     */
    'celular': string;
    /**
     * Monto a recargar en la billetera
     */
    'monto': number;
}
export interface RecargaResponseEntity {
    /**
     * Datos del cliente
     */
    'cliente': ClienteRecargaEntity;
    /**
     * Monto recargado
     */
    'montoRecargado': number;
    /**
     * Saldo anterior
     */
    'saldoAnterior': string;
    /**
     * Saldo nuevo después de la recarga
     */
    'saldoNuevo': string;
}
export interface RegistroClienteDto {
    /**
     * Número de documento de identidad del cliente
     */
    'documento': string;
    /**
     * Nombres completos del cliente
     */
    'nombres': string;
    /**
     * Correo electrónico del cliente
     */
    'email': string;
    /**
     * Número de teléfono celular del cliente
     */
    'celular': string;
}
export interface SaldoResponseEntity {
    /**
     * Datos del cliente
     */
    'cliente': ClienteSaldoEntity;
    /**
     * Saldo actual de la billetera
     */
    'saldo': string;
    /**
     * Estadísticas de transacciones
     */
    'estadisticas': EstadisticasEntity;
    /**
     * Fecha de la consulta
     */
    'fechaConsulta': string;
}

/**
 * BilleteraApi - axios parameter creator
 */
export const BilleteraApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Confirma el pago usando el ID de sesión y el token recibido por email. Valida que no esté expirado ni usado, y descuenta el monto del saldo.
         * @summary Confirmar pago con token
         * @param {ConfirmarPagoDto} confirmarPagoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerConfirmarPago: async (confirmarPagoDto: ConfirmarPagoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmarPagoDto' is not null or undefined
            assertParamExists('billeteraControllerConfirmarPago', 'confirmarPagoDto', confirmarPagoDto)
            const localVarPath = `/api/v1/billetera/confirmar-pago`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmarPagoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consulta el saldo actual de un cliente e incluye estadísticas de transacciones (recargas y compras).
         * @summary Consultar saldo de la billetera
         * @param {string} documento Número de documento del cliente
         * @param {string} celular Número de celular del cliente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerConsultarSaldo: async (documento: string, celular: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documento' is not null or undefined
            assertParamExists('billeteraControllerConsultarSaldo', 'documento', documento)
            // verify required parameter 'celular' is not null or undefined
            assertParamExists('billeteraControllerConsultarSaldo', 'celular', celular)
            const localVarPath = `/api/v1/billetera/saldo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (documento !== undefined) {
                localVarQueryParameter['documento'] = documento;
            }

            if (celular !== undefined) {
                localVarQueryParameter['celular'] = celular;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Genera un token de 6 dígitos y lo envía al email del cliente. El token expira en 15 minutos y solo se puede usar una vez.
         * @summary Iniciar proceso de pago
         * @param {PagarDto} pagarDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerIniciarPago: async (pagarDto: PagarDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pagarDto' is not null or undefined
            assertParamExists('billeteraControllerIniciarPago', 'pagarDto', pagarDto)
            const localVarPath = `/api/v1/billetera/pagar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pagarDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Carga dinero a la billetera de un cliente. Requiere documento, celular y monto mayor a 0.
         * @summary Recargar saldo a la billetera
         * @param {RecargaBilleteraDto} recargaBilleteraDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerRecargarBilletera: async (recargaBilleteraDto: RecargaBilleteraDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recargaBilleteraDto' is not null or undefined
            assertParamExists('billeteraControllerRecargarBilletera', 'recargaBilleteraDto', recargaBilleteraDto)
            const localVarPath = `/api/v1/billetera/recarga`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recargaBilleteraDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BilleteraApi - functional programming interface
 */
export const BilleteraApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BilleteraApiAxiosParamCreator(configuration)
    return {
        /**
         * Confirma el pago usando el ID de sesión y el token recibido por email. Valida que no esté expirado ni usado, y descuenta el monto del saldo.
         * @summary Confirmar pago con token
         * @param {ConfirmarPagoDto} confirmarPagoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billeteraControllerConfirmarPago(confirmarPagoDto: ConfirmarPagoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmarPagoResponseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billeteraControllerConfirmarPago(confirmarPagoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BilleteraApi.billeteraControllerConfirmarPago']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consulta el saldo actual de un cliente e incluye estadísticas de transacciones (recargas y compras).
         * @summary Consultar saldo de la billetera
         * @param {string} documento Número de documento del cliente
         * @param {string} celular Número de celular del cliente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billeteraControllerConsultarSaldo(documento: string, celular: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaldoResponseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billeteraControllerConsultarSaldo(documento, celular, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BilleteraApi.billeteraControllerConsultarSaldo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Genera un token de 6 dígitos y lo envía al email del cliente. El token expira en 15 minutos y solo se puede usar una vez.
         * @summary Iniciar proceso de pago
         * @param {PagarDto} pagarDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billeteraControllerIniciarPago(pagarDto: PagarDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagoIniciadoResponseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billeteraControllerIniciarPago(pagarDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BilleteraApi.billeteraControllerIniciarPago']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Carga dinero a la billetera de un cliente. Requiere documento, celular y monto mayor a 0.
         * @summary Recargar saldo a la billetera
         * @param {RecargaBilleteraDto} recargaBilleteraDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billeteraControllerRecargarBilletera(recargaBilleteraDto: RecargaBilleteraDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecargaResponseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billeteraControllerRecargarBilletera(recargaBilleteraDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BilleteraApi.billeteraControllerRecargarBilletera']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BilleteraApi - factory interface
 */
export const BilleteraApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BilleteraApiFp(configuration)
    return {
        /**
         * Confirma el pago usando el ID de sesión y el token recibido por email. Valida que no esté expirado ni usado, y descuenta el monto del saldo.
         * @summary Confirmar pago con token
         * @param {ConfirmarPagoDto} confirmarPagoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerConfirmarPago(confirmarPagoDto: ConfirmarPagoDto, options?: RawAxiosRequestConfig): AxiosPromise<ConfirmarPagoResponseEntity> {
            return localVarFp.billeteraControllerConfirmarPago(confirmarPagoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Consulta el saldo actual de un cliente e incluye estadísticas de transacciones (recargas y compras).
         * @summary Consultar saldo de la billetera
         * @param {string} documento Número de documento del cliente
         * @param {string} celular Número de celular del cliente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerConsultarSaldo(documento: string, celular: string, options?: RawAxiosRequestConfig): AxiosPromise<SaldoResponseEntity> {
            return localVarFp.billeteraControllerConsultarSaldo(documento, celular, options).then((request) => request(axios, basePath));
        },
        /**
         * Genera un token de 6 dígitos y lo envía al email del cliente. El token expira en 15 minutos y solo se puede usar una vez.
         * @summary Iniciar proceso de pago
         * @param {PagarDto} pagarDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerIniciarPago(pagarDto: PagarDto, options?: RawAxiosRequestConfig): AxiosPromise<PagoIniciadoResponseEntity> {
            return localVarFp.billeteraControllerIniciarPago(pagarDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Carga dinero a la billetera de un cliente. Requiere documento, celular y monto mayor a 0.
         * @summary Recargar saldo a la billetera
         * @param {RecargaBilleteraDto} recargaBilleteraDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billeteraControllerRecargarBilletera(recargaBilleteraDto: RecargaBilleteraDto, options?: RawAxiosRequestConfig): AxiosPromise<RecargaResponseEntity> {
            return localVarFp.billeteraControllerRecargarBilletera(recargaBilleteraDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BilleteraApi - object-oriented interface
 */
export class BilleteraApi extends BaseAPI {
    /**
     * Confirma el pago usando el ID de sesión y el token recibido por email. Valida que no esté expirado ni usado, y descuenta el monto del saldo.
     * @summary Confirmar pago con token
     * @param {ConfirmarPagoDto} confirmarPagoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billeteraControllerConfirmarPago(confirmarPagoDto: ConfirmarPagoDto, options?: RawAxiosRequestConfig) {
        return BilleteraApiFp(this.configuration).billeteraControllerConfirmarPago(confirmarPagoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consulta el saldo actual de un cliente e incluye estadísticas de transacciones (recargas y compras).
     * @summary Consultar saldo de la billetera
     * @param {string} documento Número de documento del cliente
     * @param {string} celular Número de celular del cliente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billeteraControllerConsultarSaldo(documento: string, celular: string, options?: RawAxiosRequestConfig) {
        return BilleteraApiFp(this.configuration).billeteraControllerConsultarSaldo(documento, celular, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Genera un token de 6 dígitos y lo envía al email del cliente. El token expira en 15 minutos y solo se puede usar una vez.
     * @summary Iniciar proceso de pago
     * @param {PagarDto} pagarDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billeteraControllerIniciarPago(pagarDto: PagarDto, options?: RawAxiosRequestConfig) {
        return BilleteraApiFp(this.configuration).billeteraControllerIniciarPago(pagarDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Carga dinero a la billetera de un cliente. Requiere documento, celular y monto mayor a 0.
     * @summary Recargar saldo a la billetera
     * @param {RecargaBilleteraDto} recargaBilleteraDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billeteraControllerRecargarBilletera(recargaBilleteraDto: RecargaBilleteraDto, options?: RawAxiosRequestConfig) {
        return BilleteraApiFp(this.configuration).billeteraControllerRecargarBilletera(recargaBilleteraDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientesApi - axios parameter creator
 */
export const ClientesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Obtener todos los clientes registrados en el sistema.
         * @summary Obtener todos los clientes registrados
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clienteControllerObtenerClientes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clientes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra un nuevo cliente en la billetera virtual mediante el servidor-database. El documento y email deben ser únicos. Saldo inicial: 0.
         * @summary Registrar un nuevo cliente
         * @param {RegistroClienteDto} registroClienteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clienteControllerRegistrarCliente: async (registroClienteDto: RegistroClienteDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registroClienteDto' is not null or undefined
            assertParamExists('clienteControllerRegistrarCliente', 'registroClienteDto', registroClienteDto)
            const localVarPath = `/api/v1/clientes/registro`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registroClienteDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientesApi - functional programming interface
 */
export const ClientesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientesApiAxiosParamCreator(configuration)
    return {
        /**
         * Obtener todos los clientes registrados en el sistema.
         * @summary Obtener todos los clientes registrados
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clienteControllerObtenerClientes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClienteResponseEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clienteControllerObtenerClientes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.clienteControllerObtenerClientes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registra un nuevo cliente en la billetera virtual mediante el servidor-database. El documento y email deben ser únicos. Saldo inicial: 0.
         * @summary Registrar un nuevo cliente
         * @param {RegistroClienteDto} registroClienteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clienteControllerRegistrarCliente(registroClienteDto: RegistroClienteDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClienteResponseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clienteControllerRegistrarCliente(registroClienteDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.clienteControllerRegistrarCliente']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientesApi - factory interface
 */
export const ClientesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientesApiFp(configuration)
    return {
        /**
         * Obtener todos los clientes registrados en el sistema.
         * @summary Obtener todos los clientes registrados
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clienteControllerObtenerClientes(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClienteResponseEntity>> {
            return localVarFp.clienteControllerObtenerClientes(options).then((request) => request(axios, basePath));
        },
        /**
         * Registra un nuevo cliente en la billetera virtual mediante el servidor-database. El documento y email deben ser únicos. Saldo inicial: 0.
         * @summary Registrar un nuevo cliente
         * @param {RegistroClienteDto} registroClienteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clienteControllerRegistrarCliente(registroClienteDto: RegistroClienteDto, options?: RawAxiosRequestConfig): AxiosPromise<ClienteResponseEntity> {
            return localVarFp.clienteControllerRegistrarCliente(registroClienteDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientesApi - object-oriented interface
 */
export class ClientesApi extends BaseAPI {
    /**
     * Obtener todos los clientes registrados en el sistema.
     * @summary Obtener todos los clientes registrados
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public clienteControllerObtenerClientes(options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clienteControllerObtenerClientes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registra un nuevo cliente en la billetera virtual mediante el servidor-database. El documento y email deben ser únicos. Saldo inicial: 0.
     * @summary Registrar un nuevo cliente
     * @param {RegistroClienteDto} registroClienteDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public clienteControllerRegistrarCliente(registroClienteDto: RegistroClienteDto, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clienteControllerRegistrarCliente(registroClienteDto, options).then((request) => request(this.axios, this.basePath));
    }
}



